CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Domains for common data types and constraints
CREATE DOMAIN argon2id_hash AS TEXT CHECK (value ~ '^\$argon2id\$v=\d+\$m=\d+,t=\d+,p=\d+\$[a-zA-Z0-9+\/=]+\$[a-zA-Z0-9+\/=]+$');

CREATE DOMAIN non_empty_text AS TEXT CHECK (trim(value) <> '');

CREATE DOMAIN non_future_timestamp AS TIMESTAMPTZ CHECK (value <= current_timestamp);

CREATE DOMAIN sha_256_hash AS TEXT CHECK (value ~ '^[a-f0-9]{64}$');

CREATE DOMAIN urlsafe_token AS TEXT CHECK (value ~ '^[A-Za-z0-9_-]{32,128}$');

CREATE DOMAIN user_agent_str AS TEXT CHECK (
    char_length(value) <= 256
    AND value ~ '^[A-Za-z0-9\\s\\-\\._;:/\\(\\),]+$'
);

-- Custom Types
CREATE TYPE session_token_type AS ENUM ('access', 'refresh');
CREATE TYPE event_type AS ENUM ('password_changed', '2fa_enabled', '2fa_disabled', 'account_locked', 'sanitized');

-- Applications Table: Stores registered applications using the service
CREATE TABLE applications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT NOT NULL UNIQUE CHECK (slug ~ '^[a-z0-9_-]{3,50}$'),
    app_name TEXT NOT NULL CHECK (char_length(app_name) >= 3 AND char_length(app_name) <= 100),
    created_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp
);

-- Users Table (only verified users live here)
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    app_id UUID NOT NULL REFERENCES applications (id) ON DELETE CASCADE,

    email_encrypted NON_EMPTY_TEXT NOT NULL,
    email_hash SHA_256_HASH NOT NULL,
    password_hash ARGON2ID_HASH NOT NULL,
    phone_encrypted NON_EMPTY_TEXT,
    phone_hash SHA_256_HASH,

    is_email_verified BOOLEAN NOT NULL DEFAULT TRUE,
    is_2fa_enabled BOOLEAN NOT NULL DEFAULT FALSE,
    is_suspended BOOLEAN NOT NULL DEFAULT FALSE,
    failed_login_count INTEGER NOT NULL DEFAULT 0,

    created_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp,
    updated_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp,
    last_login_at NON_FUTURE_TIMESTAMP,
    scheduled_for_deletion_at NON_FUTURE_TIMESTAMP,
    account_locked_at NON_FUTURE_TIMESTAMP,

    CONSTRAINT unique_user_per_app UNIQUE (email_hash, app_id),
    CONSTRAINT chk_email_hash_present CHECK ((email_encrypted IS NULL AND email_hash IS NULL) OR (email_encrypted IS NOT NULL AND email_hash IS NOT NULL)),
    CONSTRAINT chk_phone_hash_present CHECK ((phone_encrypted IS NULL AND phone_hash IS NULL) OR (phone_encrypted IS NOT NULL AND phone_hash IS NOT NULL))
);

ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY policy_tenant_isolation ON users USING (app_id = current_setting('app.id')::UUID);

-- Pending Users Table (awaiting email verification)
CREATE TABLE pending_users (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    token URLSAFE_TOKEN NOT NULL,

    app_id UUID NOT NULL REFERENCES applications (id) ON DELETE CASCADE,
    email_encrypted NON_EMPTY_TEXT NOT NULL,
    email_hash SHA_256_HASH NOT NULL,

    created_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp,
    expires_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp + INTERVAL '24 hour',

    ip_address INET CHECK (ip_address IS NULL OR family(ip_address) IN (4, 6)),
    user_agent USER_AGENT_STR,

    CONSTRAINT unique_pending_user_per_app UNIQUE (email_hash, app_id)
);

-- Device Fingerprints Table: Stores device fingerprints for users
CREATE TABLE device_fingerprints (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users (id) ON DELETE CASCADE,
    app_id UUID NOT NULL REFERENCES applications (id) ON DELETE CASCADE,

    fingerprint_hash SHA_256_HASH NOT NULL,
    device_name TEXT NOT NULL CHECK (char_length(device_name) <= 100),
    user_agent USER_AGENT_STR,
    last_seen_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp,

    CONSTRAINT unique_fingerprint_per_user UNIQUE (user_id, fingerprint_hash)
);

ALTER TABLE device_fingerprints ENABLE ROW LEVEL SECURITY;
CREATE POLICY policy_tenant_isolation ON device_fingerprints USING (app_id = current_setting('app.id')::UUID);

-- Sessions Table (opaque session tokens)
CREATE TABLE sessions (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    token URLSAFE_TOKEN NOT NULL,
    token_type SESSION_TOKEN_TYPE NOT NULL DEFAULT 'access',

    user_id UUID NOT NULL REFERENCES users (id) ON DELETE CASCADE,
    app_id UUID NOT NULL REFERENCES applications (id) ON DELETE CASCADE,

    ip_address INET CHECK (ip_address IS NULL OR family(ip_address) IN (4, 6)),
    user_agent USER_AGENT_STR,

    created_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp,
    expires_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp + INTERVAL '15 minutes',

    is_active BOOLEAN NOT NULL DEFAULT TRUE
);

ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
CREATE POLICY policy_tenant_isolation ON sessions USING (app_id = current_setting('app.id')::UUID);

-- Password Reset Tokens
CREATE TABLE password_reset_tokens (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    token URLSAFE_TOKEN NOT NULL,

    user_id UUID NOT NULL REFERENCES users (id) ON DELETE CASCADE,
    created_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp,
    expires_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp + INTERVAL '1 hour'
);

-- TOTP 2FA Secrets
CREATE TABLE totp_secrets (
    user_id UUID PRIMARY KEY REFERENCES users (id) ON DELETE CASCADE,
    secret_encrypted NON_EMPTY_TEXT NOT NULL,
    secret_hash SHA_256_HASH NOT NULL,
    key_version SMALLINT NOT NULL DEFAULT 1,
    created_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp
);

ALTER TABLE totp_secrets ENABLE ROW LEVEL SECURITY;
CREATE POLICY policy_tenant_isolation ON totp_secrets
USING (user_id IN (
    SELECT id FROM users
    WHERE app_id = current_setting('app.id')::UUID
));

-- Multi-Factor Authentication Backup Codes Table: Stores backup codes for 2FA
CREATE TABLE mfa_backup_codes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users (id) ON DELETE CASCADE,
    app_id UUID NOT NULL REFERENCES applications (id) ON DELETE CASCADE,
    code_hash SHA_256_HASH NOT NULL,
    used BOOLEAN NOT NULL DEFAULT FALSE,
    created_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp
);

ALTER TABLE mfa_backup_codes ENABLE ROW LEVEL SECURITY;
CREATE POLICY policy_tenant_isolation ON mfa_backup_codes USING (app_id = current_setting('app.id')::UUID);

-- Login Attempt Logs (brute force detection, audit logs)
CREATE TABLE login_attempts (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    user_id UUID REFERENCES users (id) ON DELETE SET NULL,
    app_id UUID NOT NULL REFERENCES applications (id) ON DELETE CASCADE,

    email_encrypted NON_EMPTY_TEXT NOT NULL CHECK (char_length(email_encrypted) >= 5),
    email_hash SHA_256_HASH NOT NULL,
    ip_address INET CHECK (ip_address IS NULL OR family(ip_address) IN (4, 6)),
    user_agent USER_AGENT_STR,

    was_successful BOOLEAN NOT NULL,
    attempted_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp
);

-- Security Events Table: Tracks significant security-related events
CREATE TABLE security_events (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES users (id) ON DELETE CASCADE,
    app_id UUID NOT NULL REFERENCES applications (id) ON DELETE CASCADE,
    event_type EVENT_TYPE NOT NULL,
    metadata JSONB,
    occurred_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp
);

ALTER TABLE security_events ENABLE ROW LEVEL SECURITY;
CREATE POLICY policy_tenant_isolation ON security_events USING (app_id = current_setting('app.id')::UUID);

-- IP Blocklist Table: Stores blocked IP addresses
CREATE TABLE ip_blocklist (
    ip_address INET PRIMARY KEY,
    blocked_by_user_id UUID REFERENCES users (id) ON DELETE SET NULL,
    manual_block BOOLEAN NOT NULL DEFAULT FALSE,
    reason TEXT,
    duration INTERVAL NOT NULL DEFAULT '3 days' CHECK (duration > INTERVAL '0 seconds'),
    blocked_at NON_FUTURE_TIMESTAMP NOT NULL DEFAULT current_timestamp
);

-- Indexes for performance
CREATE INDEX idx_users_email_app ON users (email_hash, app_id);
CREATE INDEX idx_pending_users_expires ON pending_users (expires_at);
CREATE INDEX idx_sessions_user_expires ON sessions (user_id, expires_at);
CREATE INDEX idx_sessions_active_expires ON sessions (is_active, expires_at);
CREATE INDEX idx_fingerprint_user_seen ON device_fingerprints (user_id, last_seen_at DESC);
CREATE INDEX idx_login_attempts_app_time ON login_attempts (app_id, attempted_at DESC);
CREATE INDEX idx_login_attempts_user_time ON login_attempts (user_id, attempted_at DESC);

-- Revoke public access
REVOKE ALL ON ALL TABLES IN SCHEMA public FROM public;
